Binary files original_files/.git/index and modified_files/.git/index differ
Only in original_files/.git: ORIG_HEAD
diff -r -u original_files/lib/plugins.js modified_files/lib/plugins.js
--- original_files/lib/plugins.js	2016-03-30 21:01:39.633573069 -0700
+++ modified_files/lib/plugins.js	2016-03-30 14:30:27.773027825 -0700
@@ -6,6 +6,7 @@
 
 
 var SATOSHI_FACTOR = 1e8;
+var FINNEY_FACTOR = 1e3;
 var SESSION_TIMEOUT = 60 * 60 * 1000;
 var POLLING_RATE = 60 * 1000; // poll each minute
 
@@ -15,6 +16,10 @@
 var tickerPlugin = null;
 var traderPlugin = null;
 var walletPlugin = null;
+var tickerPluginEth = null;
+var traderPluginEth = null;
+var walletPluginEth = null;
+
 var idVerifierPlugin = null;
 
 var currentlyUsedPlugins = {};
@@ -26,11 +31,21 @@
 var lastBalances = null;
 var lastRates = {};
 
+var lastBalancesEth = null;
+var lastRatesEth = {};
+
 var balanceInterval = null;
 var rateInterval = null;
 var tradeInterval = null;
 
+var balanceIntervalEth = null;
+var rateIntervalEth = null;
+var tradeIntervalEth = null;
+
+
+
 var tradesQueue = [];
+var tradesQueueEth = [];
 var sessions = {};
 
 
@@ -49,8 +64,11 @@
   // plugins definitions
   var moduleMethods = {
     ticker: [ 'ticker' ],
+    tickerEth: [ 'ticker' ],
     trader: [ 'balance', 'purchase', 'sell' ],
+    traderEth: [ 'balance', 'purchase', 'sell' ],
     wallet: [ 'balance', 'sendBitcoins' ],
+    walletEth: [ 'balance', 'sendEthers' ],
     idVerifier: [ 'verifyUser', 'verifyTransaction' ]
   };
 
@@ -136,6 +154,18 @@
     }
   );
 
+  loadOrConfigPlugin(
+    tickerPluginEth,
+    'tickerEth',
+    deviceCurrency, // device currency
+    function onTickerChange(newTicker) {
+      tickerPluginEth = newTicker;
+      pollRateEth();
+    }
+  );
+
+
+
   // WALLET [required] configure (or load)
   loadOrConfigPlugin(
     walletPlugin,
@@ -147,6 +177,19 @@
     }
   );
 
+  // WALLET [required] configure (or load)
+  loadOrConfigPlugin(
+    walletPluginEth,
+    'transferEth',
+    null,
+    function onWalletChange(newWallet) {
+      walletPluginEth = newWallet;
+      pollBalanceEth();
+    }
+  );
+
+
+
   // TRADER [optional] configure (or load)
   traderPlugin = loadOrConfigPlugin(
     traderPlugin,
@@ -159,6 +202,18 @@
     }
   );
 
+  traderPluginEth = loadOrConfigPlugin(
+    traderPluginEth,
+    'trade',
+    null,
+    function onTraderChange(newTrader) {
+      traderPluginEth = newTrader;
+      if (newTrader === null) stopTrader();
+      else startTrader();
+    }
+  );
+
+ 
   // ID VERIFIER [optional] configure (or load)
   idVerifierPlugin = loadOrConfigPlugin(
     idVerifierPlugin,
@@ -190,6 +245,26 @@
   });
 };
 
+exports.tradeEth = function tradeEth(rawTrade, deviceFingerprint) {
+  var sessionInfo = sessions[deviceFingerprint];
+
+  if (!sessionInfo) {
+    sessions[deviceFingerprint] = {
+      timestamp: Date.now(),
+      reaper: setTimeout(function() {
+        delete sessions[deviceFingerprint];
+      }, SESSION_TIMEOUT)
+    };
+  }
+
+  tradesQueueEth.push({
+    currency: rawTrade.currency,
+    finneys: rawTrade.finneys
+  });
+};
+
+
+
 exports.fiatBalance = function fiatBalance() {
   var rawRate = exports.getDeviceRate().rates.ask;
   var commission = cachedConfig.exchanges.settings.commission;
@@ -218,6 +293,36 @@
   return fiatTransferBalance;
 };
 
+exports.fiatBalanceEth = function fiatBalanceEth() {
+  var rawRate = exports.getDeviceRateEth().rates.ask;
+  var commission = cachedConfig.exchanges.settings.commissionEth;
+
+  if (!rawRate || !lastBalancesEth) return null;
+
+  // The rate is actually our commission times real rate.
+  var rate = commission * rawRate;
+
+  // `lowBalanceMargin` is our safety net. It's a number > 1, and we divide
+  // all our balances by it to provide a safety margin.
+  var lowBalanceMargin = cachedConfig.exchanges.settings.lowBalanceMargin;
+
+  // `balance.transferBalance` is the balance of our transfer account (the one
+  // we use to send Bitcoins to clients) in satoshis.
+  var transferBalance = lastBalancesEth.transferBalance.ETH;
+
+  // Since `transferBalance` is in satoshis, we need to turn it into
+  // bitcoins and then fiat to learn how much fiat currency we can exchange.
+  //
+  // Unit validity proof: [ $ ] = [ (B * 10^8) / 10^8 * $/B ]
+  //                      [ $ ] = [ B * $/B ]
+  //                      [ $ ] = [ $ ]
+  var fiatTransferBalance = ((transferBalance / FINNEY_FACTOR) * rate) / lowBalanceMargin;
+
+  return fiatTransferBalance;
+};
+
+
+
 exports.sendBitcoins = function sendBitcoins(deviceFingerprint, tx, callback) {
   db.summonTransaction(deviceFingerprint, tx, function(err, txInfo) {
     if (err) return callback(err);
@@ -263,6 +368,51 @@
   });
 };
 
+exports.sendEthers = function sendEthers(deviceFingerprint, tx, callback) {
+  db.summonTransactionEth(deviceFingerprint, tx, function(err, txInfo) {
+    if (err) return callback(err);
+
+    if (!txInfo) {
+      clearSession(deviceFingerprint);
+
+      return walletPluginEth.sendEthers(
+        tx.toAddress,
+        tx.finneys,
+        cachedConfig.exchanges.settings.transactionFee,
+
+        function(err, txHash) {
+          if (err) {
+            var status = err.name === 'InsufficientFunds' ?
+              'insufficientFunds' :
+              'failed';
+
+            db.reportTransactionErrorEth(tx, err.message, status);
+            return callback(err);
+          }
+
+          db.completeTransactionEth(tx, txHash);
+          pollBalanceEth();
+          callback(null, txHash);
+        }
+      );
+    }
+
+    // Out of bitcoins: special case
+    var txErr = null;
+    if (txInfo.err) {
+      txErr = new Error(txInfo.err);
+      if (txInfo.status === 'insufficientFunds') {
+        txErr.name = 'InsufficientFunds';
+      }
+    }
+
+    // transaction exists, but txHash might be null,
+    // in which case ATM should continue polling
+    pollBalanceEth();
+    callback(txErr, txInfo.txHash);
+  });
+};
+
 
 /*
  * Polling livecycle
@@ -274,10 +424,19 @@
     balanceInterval = setInterval(pollBalance, POLLING_RATE);
   }
 
+  if (!balanceIntervalEth) {
+    balanceIntervalEth = setInterval(pollBalanceEth, POLLING_RATE);
+  }
+
+
   if (!rateInterval) {
     rateInterval = setInterval(pollRate, POLLING_RATE);
   }
 
+  if (!rateIntervalEth) {
+    rateIntervalEth = setInterval(pollRateEth, POLLING_RATE);
+  }
+
   startTrader();
 };
 
@@ -292,6 +451,14 @@
       cachedConfig.exchanges.settings.tradeInterval
     );
   }
+
+  if (traderPluginEth && !tradeIntervalEth) {
+    tradeIntervalEth = setInterval(
+      executeTradesEth,
+      cachedConfig.exchanges.settings.tradeInterval
+    );
+  }
+
 }
 function stopTrader() {
   if (tradeInterval) {
@@ -328,6 +495,32 @@
     return callback && callback(null, lastBalances);
   });
 }
+function pollBalanceEth(callback) {
+  logger.debug('collecting eth balance');
+
+  var jobs = {
+    transferBalance: walletPluginEth.balance
+  };
+
+  // only add if trader is enabled
+  // if (traderPlugin) {
+  //   // NOTE: we would need to handle when traderCurrency!=deviceCurrency
+  //   jobs.tradeBalance = traderPlugin.balance;
+  // }
+
+  async.parallel(jobs, function(err, balance) {
+    if (err) {
+      logger.error(err);
+      return callback && callback(err);
+    }
+
+    logger.debug('Balance update:', balance);
+    balance.timestamp = Date.now();
+    lastBalancesEth = balance;
+
+    return callback && callback(null, lastBalancesEth);
+  });
+}
 
 function pollRate(callback) {
   logger.debug('polling for rates (%s)', tickerPlugin.NAME);
@@ -345,11 +538,25 @@
     return callback && callback(null, lastRates);
   });
 }
+function pollRateEth(callback) {
+  logger.debug('polling for eth rates (%s)', tickerPluginEth.NAME);
+
+  tickerPluginEth.ticker(deviceCurrency, function(err, resRates) {
+    if (err) {
+      logger.error(err);
+      return callback && callback(err);
+    }
+
+    logger.debug('got rates: %j', resRates);
+    resRates.timestamp = new Date();
+    lastRatesEth = resRates;
+
+    return callback && callback(null, lastRatesEth);
+  });
+}
+
 
 
-/*
- * Getters | Helpers
- */
 function getLastRate(currency) {
   if (!lastRates) return null;
 
@@ -358,16 +565,37 @@
 
   return lastRates[tmpCurrency];
 }
+function getLastRateEth(currency) {
+  if (!lastRatesEth) return null;
+
+  var tmpCurrency = currency || deviceCurrency;
+  if (!lastRatesEth[tmpCurrency]) return null;
+
+  return lastRatesEth[tmpCurrency];
+}
 exports.getDeviceRate = function getDeviceRate() {
   return getLastRate(deviceCurrency);
 };
 
+exports.getDeviceRateEth = function getDeviceRateEth() {
+  return getLastRateEth(deviceCurrency);
+};
+
+
 exports.getBalance = function getBalance() {
   if (!lastBalances) return null;
 
   return lastBalances.transferBalance;
 };
 
+exports.getBalanceEth = function getBalanceEth() {
+  if (!lastBalancesEth) return null;
+
+  return lastBalancesEth.transferBalance;
+};
+
+
+
 function clearSession(deviceFingerprint) {
   var session = sessions[deviceFingerprint];
   if (session) {
@@ -388,6 +616,14 @@
   });
 }
 
+function purchaseEth(trade, callback) {
+  traderPluginEth.purchase(trade.finneys, null, function(err) {
+    if (err) return callback(err);
+    pollBalanceEth();
+    if (typeof callback === 'function') callback();
+  });
+}
+
 function consolidateTrades() {
   // NOTE: value in satoshis stays the same no matter the currency
   var consolidatedTrade = {
@@ -403,6 +639,21 @@
   return consolidatedTrade;
 }
 
+function consolidateTradesEth() {
+  // NOTE: value in satoshis stays the same no matter the currency
+  var consolidatedTrade = {
+    currency: deviceCurrency,
+    finneys: tradesQueueEth.reduce(function(prev, current) {
+      return prev + current.finneys;
+    }, 0)
+  };
+
+  tradesQueueEth = [];
+
+  logger.debug('consolidated: ', JSON.stringify(consolidatedTrade));
+  return consolidatedTrade;
+}
+
 function executeTrades() {
   if (!traderPlugin) return;
 
@@ -424,6 +675,29 @@
   });
 }
 
+function executeTradesEth() {
+  if (!traderPluginEth) return;
+
+  logger.debug('checking for trades');
+
+  var trade = consolidateTradesEth();
+
+  if (trade.finneys === 0) {
+    logger.debug('rejecting 0 trade');
+    return;
+  }
+
+  logger.debug('making a trade: %d', trade.finneys / FINNEY_FACTOR);
+  purchaseEth(trade, function(err) {
+    if (err) {
+      tradesQueueEth.push(trade);
+      logger.error(err);
+    }
+  });
+}
+
+
+
 /*
  * ID Verifier functions
  */
diff -r -u original_files/lib/postgresql_interface.js modified_files/lib/postgresql_interface.js
--- original_files/lib/postgresql_interface.js	2016-03-30 21:01:39.633573069 -0700
+++ modified_files/lib/postgresql_interface.js	2016-03-30 14:30:27.821027803 -0700
@@ -30,6 +30,16 @@
     cb);
 };
 
+PostgresqlInterface.prototype.recordBillEth = 
+  function recordBillEth(deviceFingerprint, rec, cb) {
+
+  this.client.query('INSERT INTO bills_eth (device_fingerprint, denomination, currency_code, ' +
+    'finneys, to_address, transaction_id, device_time) ' +
+    'VALUES ($1, $2, $3, $4, $5, $6, $7)',
+    [deviceFingerprint, rec.fiat, rec.currency, rec.finneys, rec.toAddress, rec.txId, rec.deviceTime],
+    cb);
+}
+
 PostgresqlInterface.prototype.recordDeviceEvent = 
   function recordBillValidatorEvent(deviceFingerprint, event, cb) {
 
@@ -57,12 +67,40 @@
   });
 };
 
+PostgresqlInterface.prototype.summonTransactionEth =
+  function summonTransactionEth(deviceFingerprint, tx, cb) {
+  // First do an INSERT
+  // If it worked, go ahead with transaction
+  // If duplicate, fetch status and return
+  var self = this;
+  this.client.query('INSERT INTO transactions_eth (id, status, device_fingerprint, ' +
+      'to_address, finneys, currency_code, fiat) ' +
+      'VALUES ($1, $2, $3, $4, $5, $6, $7)', [tx.txId, 'pending', deviceFingerprint,
+      tx.toAddress, tx.finneys, tx.currencyCode, tx.fiat],
+      function (err) {
+    if (err && PG_ERRORS[err.code] === 'uniqueViolation')
+      return self._fetchTransactionEth(tx.txId, cb);
+    if (err) return cb(err);
+    cb();
+  });
+};
+
+
+
 PostgresqlInterface.prototype.reportTransactionError =
   function reportTransactionError(tx, errString, status) {
   this.client.query('UPDATE transactions SET status=$1, error=$2 WHERE id=$3',
     [status, errString, tx.txId]);
 };
 
+PostgresqlInterface.prototype.reportTransactionErrorEth =
+  function reportTransactionErrorEth(tx, errString, status) {
+  this.client.query('UPDATE transactions_eth SET status=$1, error=$2 WHERE id=$3',
+    [status, errString, tx.txId]);
+};
+
+
+
 PostgresqlInterface.prototype.completeTransaction =
   function completeTransaction(tx, txHash) {
   if (txHash)
@@ -73,12 +111,38 @@
       ['failed', 'No txHash received', tx.txId]);
 };
 
+PostgresqlInterface.prototype.completeTransactionEth =
+  function completeTransaction(tx, txHash) {
+  if (txHash)
+    this.client.query('UPDATE transactions_eth SET tx_hash=$1, status=$2, completed=now() WHERE id=$3',
+      [txHash, 'completed', tx.txId]);
+  else
+    this.client.query('UPDATE transactions_eth SET status=$1, error=$2 WHERE id=$3',
+      ['failed', 'No txHash received', tx.txId]);
+};
+
+
+
 PostgresqlInterface.prototype._fetchTransaction =
     function _fetchTransaction(txId, cb) {
   this.client.query('SELECT status, tx_hash, error FROM transactions WHERE id=$1',
       [txId], function (err, results) {
     if (err) return cb(err);
 
+    // This should never happen, since we already checked for existence
+    if (results.rows.length === 0) return cb(new Error('Couldn\'t find transaction.'));
+
+    var result = results.rows[0];
+    cb(null, {txHash: result.tx_hash, err: result.error, status: result.status});
+  });
+};
+
+PostgresqlInterface.prototype._fetchTransactionEth =
+    function _fetchTransaction(txId, cb) {
+  this.client.query('SELECT status, tx_hash, error FROM transactions_eth WHERE id=$1',
+      [txId], function (err, results) {
+    if (err) return cb(err);
+
     // This should never happen, since we already checked for existence
     if (results.rows.length === 0) return cb(new Error('Couldn\'t find transaction.'));
 
diff -r -u original_files/lib/routes.js modified_files/lib/routes.js
--- original_files/lib/routes.js	2016-03-30 21:01:39.633573069 -0700
+++ modified_files/lib/routes.js	2016-03-30 14:30:27.725027847 -0700
@@ -62,12 +62,67 @@
   res.json(response);
 }
 
+function pollEth(req, res) {
+  var rateRec = plugins.getDeviceRateEth();
+  var balanceRec = plugins.getBalanceEth();
+  var fingerprint = getFingerprint(req);
+
+  logger.debug('poll request from: %s', fingerprint);
+
+  // `rateRec` and `balanceRec` are both objects, so there's no danger
+  // of misinterpreting rate or balance === 0 as 'Server initializing'.
+  if (!rateRec || !balanceRec) {
+    return res.json({err: 'Server initializing'});
+  }
+
+  var now = Date.now();
+  if (now - rateRec.timestamp > STALE_TICKER) {
+    return res.json({err: 'Stale ticker'});
+  }
+
+  if (now - balanceRec.timestamp > STALE_BALANCE) {
+    return res.json({err: 'Stale balance'});
+  }
+
+  var rate = rateRec.rates.ask;
+  if (rate === null) return res.json({err: 'No rate available'});
+  var fiatBalance = plugins.fiatBalanceEth(fingerprint);
+  if (fiatBalance === null) return res.json({err: 'No balance available'});
+
+  var config = plugins.getCachedConfig();
+  var complianceSettings = config.exchanges.settings.compliance;
+
+  var response = {
+    err: null,
+    rate: rate * config.exchanges.settings.commission,
+    fiat: fiatBalance,
+    locale: config.brain.locale,
+    txLimit: parseInt(complianceSettings.maximum.limit, 10),
+    idVerificationEnabled: complianceSettings.idVerificationEnabled
+  };
+
+  if (response.idVerificationEnabled)
+    response.idVerificationLimit = complianceSettings.idVerificationLimit;
+
+  res.json(response);
+}
+
 function trade(req, res) {
+  console.log('TRADE: ' + JSON.stringify(req.body));
   var fingerprint = getFingerprint(req);
   plugins.trade(req.body, fingerprint);
   res.json({err: null});
 }
 
+function tradeEth(req, res) {
+  console.log('TRADEETH: ' + JSON.stringify(req.body));
+  var fingerprint = getFingerprint(req);
+  plugins.tradeEth(req.body, fingerprint);
+  res.json({err: null});
+}
+
+
+
 function deviceEvent(req, res) {
   var fingerprint = req.connection.getPeerCertificate().fingerprint;
   plugins.event(req.body, fingerprint);
@@ -101,8 +156,25 @@
 }
 
 function send(req, res) {
+  console.log('SEND: ' + JSON.stringify(req.body));
   var fingerprint = getFingerprint(req);
   plugins.sendBitcoins(fingerprint, req.body, function(err, txHash) {
+    console.log(err);
+    console.log(txHash);
+    res.json({
+      err: err && err.message,
+      txHash: txHash,
+      errType: err && err.name
+    });
+  });
+}
+
+function sendEth(req, res) {
+  console.log('SENDETH: ' + JSON.stringify(req.body));
+  var fingerprint = getFingerprint(req);
+  plugins.sendEthers(fingerprint, req.body, function(err, txHash) {
+    console.log(err);
+    console.log(txHash);
     res.json({
       err: err && err.message,
       txHash: txHash,
@@ -138,8 +210,11 @@
   var app = localConfig.app;
 
   app.get('/poll', authMiddleware, poll);
+  app.get('/pollEth', authMiddleware, pollEth);
   app.post('/send', authMiddleware, send);
+  app.post('/sendEth', authMiddleware, sendEth);
   app.post('/trade', authMiddleware, trade);
+  app.post('/tradeEth', authMiddleware, tradeEth);
   app.post('/event', authMiddleware, deviceEvent);
   app.post('/verify_user', authMiddleware, verifyUser);
   app.post('/verify_transaction', authMiddleware, verifyTransaction);
